---
title: "Soil depth prediction: comparison of statistical approaches"
author: "Taciara Zborowski Horst; Ricardo Simão Diniz Dalmolin; Jean Michel Moura-Bueno; Alessandro Samuel-Rosa"
date: "15 de janeiro de 2018"
output: bookdown::html_document2
lang: pt
---

```{r, echo=FALSE, eval=FALSE}
rmarkdown::render('code.Rmd', encoding = 'UTF-8', output_dir = "../docs")
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE, warning=FALSE}
library(magrittr)
library(dplyr)
library(glue)
library(lattice)
library(latticeExtra)
library(georob)
library(sp)
library(mapview)
library(raster)
library(rmarkdown)
library(caret)
library(randomForest)
```

```{r}
fstats <- function(y, yhat) {n              <- length(y)
                             r              <- cor(y, yhat)
                             lmy            <- lm(y~yhat)
                             a              <- coefficients(lmy)[1]
                             b              <- coefficients(lmy)[2]
                             r2             <- summary(lmy)$r.squared[1]
                             bias           <- mean(yhat)-mean(y)
                             msd            <- sum((yhat-y)^2)/n
                             rmse           <- sqrt(msd)
                             msd.c          <- sum((yhat-bias-y)^2)/n
                             rmse.c         <- sqrt(msd.c)
                             sb             <- (mean(yhat)-mean(y))^2
                             nu             <- ((1-b)^2)*(var(yhat)*((n-1)/n))
                             lc             <- (1-r^2)*(var(y)*((n-1)/n))
                             rpd            <- sd(y)/rmse
                             q1             <- quantile(y)[2]
                             q3             <- quantile(y)[4]
                             rpiq           <- (q3-q1)/rmse
                             error.s        <- round(c(r2, rmse, bias),3)
                             names(error.s) <- c("R2", "RMSE", "bias")
                             return(error.s)}
```


#CONF1


```{r, include=FALSE}
rm(list = ls())
pontos <- read.csv('../data/GateadosDados.csv', dec = ".", sep= ";", stringsAsFactors = FALSE)
pontos$PFd <- pontos$PF / 10 %>% round()
pontos$coordX <- pontos$X
pontos$coordY <- pontos$Y
sp::coordinates(pontos) <- c('coordX' , 'coordY')
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sp::proj4string(pontos) <- wgs84utm22s
```

```{r, include=FALSE}
summary(pontos$PFd)
```

```{r fig.asp=1, include=FALSE}
histogram(pontos$PFd) + latticeExtra::layer(panel.grid(v = 0)) + latticeExtra::layer(panel.rug(pontos$PFd))
```

```{r, message=FALSE, include=FALSE}
DECLI <- raster::raster("../data/Covars/DECLI.tif")
ELEV <- raster::raster("../data/Covars/ELEV.tif")
VD <- raster::raster("../data/Covars/VD.tif")
TWI <- raster::raster("../data/Covars/TWI.tif")
CNBL <- raster::raster("../data/Covars/CNBL.tif")
```

```{r, include=FALSE}
pontos$DECLI <- raster::extract(DECLI, pontos)
pontos$ELEV <- raster::extract(ELEV, pontos)
pontos$VD <- raster::extract(VD, pontos)
pontos$TWI <- raster::extract(TWI, pontos)
pontos$CNBL <- raster::extract(CNBL, pontos)
```

```{r,include=FALSE}
#formulação dos modelos
form <- PFd ~ DECLI + ELEV + VD + TWI + CNBL
form1 <- PFd ~ X + Y
form2 <-  PFd ~ DECLI + ELEV + VD + TWI + CNBL + X + Y
```

#Modelo Random forest e 3 formulações (excluir)

```{r, include=FALSE}
#RANDOM FOREST FORM
rf_fit <- caret::train(form, data = pontos@data,
                       method = "rf", tuneLength = 1, importance = TRUE, trControl = trainControl("LOOCV"))
rf_fit

train.stats <- fstats(pontos$PFd, predict(rf_fit))=
train.stats
```

```{r, include=FALSE}
#RANDOM FOREST FORM 2
rf_fit2 <- caret::train(form2, data = pontos@data,
                       method = "rf", tuneLength = 1, importance = TRUE, trControl = trainControl("LOOCV"))
rf_fit2

train.stats <- fstats(pontos$PFd, predict(rf_fit2))
train.stats
```

```{r,include=FALSE}
#RANDOM FOREST FORM 3
rf_fit3 <- caret::train(form3, data = pontos@data,
                       method = "rf", tuneLength = 1, importance = TRUE, trControl = trainControl("LOOCV"))
rf_fit3

train.stats <- fstats(pontos$PFd, predict(rf_fit3))
train.stats
```



#Regressão Linear múltipla e 3 formulações

```{r, include=FALSE}
#LINEAR REGRESSION FORM
lm_fit <- train(
  form = form, data = pontos@data, method = "lmStepAIC", tuneLength = 1, importance = TRUE,
  na.action = na.omit, trControl = trainControl(method = "LOOCV"))

summary(lm_fit)

# Perform validation
train.stats <- fstats(pontos$PFd, predict(lm_fit)) # Compute training stats
train.stats
```

```{r, include=FALSE}
#LINEAR REGRESSION FORM 2
lm_fit2 <- train(
  form = form2, data = pontos, locations = ~ coordX + coordY, method = "lmStepAIC", tuneLength = 1, importance = TRUE,
  na.action = na.omit, trControl = trainControl(method = "LOOCV"))

summary(lm_fit2)

train.stats <- fstats(pontos$PFd, predict(lm_fit2))# Compute training stats
train.stats
```

```{r, include=FALSE}
#LINEAR REGRESSION FORM 3
lm_fit3 <- train(
  form = form3, data = pontos, locations = ~ coordX + coordY, method = "lmStepAIC", tuneLength = 1, importance = TRUE,
  na.action = na.omit, trControl = trainControl(method = "LOOCV"))

summary(lm_fit3)

train.stats <- fstats(pontos$PFd, predict(lm_fit3))# Compute training stats
train.stats
```

#CONF2

```{r, include=FALSE}
rm(list = ls())
pontos <- read.csv('../data/GateadosDados.csv', dec = ".", sep= ";", stringsAsFactors = FALSE)
pontos$PFd <- pontos$PF / 10 %>% round()
sp::coordinates(pontos) <- c('X' , 'Y')
wgs84utm22s <- sp::CRS('+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs')
sp::proj4string(pontos) <- wgs84utm22s
```

```{r,include=FALSE}
#formulação dos modelos
form <- PFd ~ DECLI + ELEV + VD + TWI + CNBL
form4 <- PFd ~ X + Y
form5 <-  PFd ~ DECLI + ELEV + VD + TWI + CNBL + X + Y
```

```{r, message=FALSE, include=FALSE}
DECLI <- raster::raster("../data/Covars/DECLI.tif")
ELEV <- raster::raster("../data/Covars/ELEV.tif")
VD <- raster::raster("../data/Covars/VD.tif")
TWI <- raster::raster("../data/Covars/TWI.tif")
CNBL <- raster::raster("../data/Covars/CNBL.tif")
```

```{r, include=FALSE}
pontos$DECLI <- raster::extract(DECLI, pontos)
pontos$ELEV <- raster::extract(ELEV, pontos)
pontos$VD <- raster::extract(VD, pontos)
pontos$TWI <- raster::extract(TWI, pontos)
pontos$CNBL <- raster::extract(CNBL, pontos)
```


# linear mixed effects model

#form

```{r, fig.asp=1}
distmax <-dist(pontos@coords) %>% max() / 3
limites <- seq(0, distmax, length.out = 20)
vario <- georob::sample.variogram(form,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180), estimator = "matheron") %>%
plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma", type = "b") # ASR: use lines and points to see the variogram
```

```{r fig.asp=1, fig.width=7, fig.height=7, fig.cap=" Variograma amostral"}
distmax <-dist(pontos@coords) %>% max() / 3
limites <- seq(0, distmax, length.out = 20)

vario <- georob::sample.variogram(form,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma")
```

```{r}
#ajustei uma função sem fixar o nugget
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 10, nugget = 0.5, scale = 70), weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

```{r, warning=FALSE}
nugget <- 0.25
vario_fit_error <- georob::georob(
   form, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = nugget,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']] - nugget,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = TRUE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))

summary(vario_fit_error)
```

```{r}
plot(vario)
lines(vario_fit, col = "blue")
lines(vario_fit_error, col = "red")
```

```{r}
grid <- stack(DECLI, ELEV, TWI, VD, CNBL)
grid <- as(grid, 'SpatialPointsDataFrame')
colnames(grid@coords) <- colnames(pontos@coords)
```

```{r, fig.width=10, warning=FALSE,  fig.cap= "Mapas de predição - saída extendida do georob"}
#ESPACIAL
pred_ponto <- predict(
  vario_fit_error, newdata = grid, locations = ~ X + Y, type = "response", signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
spplot(pred_ponto)
```

```{r, fig.width=10}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range(na.rm = TRUE)
at <- seq(at[1], at[2], length.out = 20)
```

```{r, fig.asp=1}
spplot(pred_ponto, zcol = "lower", at = at, main="Limite inferior")
spplot(pred_ponto, zcol="pred", at=at, main="Realização mais provável")
spplot(pred_ponto, zcol="upper", at=at, main="Limite superior")
```

```{r}
#AVALIAÇÃO DA QUALIDADE
nset <- length(pontos) - 1
validacao <- georob::cv(vario_fit_error, nset = nset)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
```

```{r}
plot(validacao)
```


#form4

```{r fig.asp=1, fig.width=7, fig.height=7, fig.cap=" Variograma amostral"}
distmax <-dist(pontos@coords) %>% max() / 3
limites <- seq(0, distmax, length.out = 20)

vario <- georob::sample.variogram(PFd ~ X + Y,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma")
```

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 10, nugget = 0.5, scale = 70), weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

```{r, fig.asp = 1, fig.cap=" Variograma amostral (em preto) e função exponencial a ele ajustado (vermelho)"}
plot(vario, xlab = 'Distância de separação (m)', ylab = 'Semivariância', annotate.npairs = TRUE)
lines(vario_fit, col = "red", lty = 'dashed')
```

```{r, warning=FALSE}
nugget <- 0.25
vario_fit_error <- georob::georob(
   PFd ~ X + Y, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = nugget,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']] - nugget,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = TRUE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))
summary(vario_fit_error)
```

```{r}
pistola <- raster::shapefile("../data/Contorno/limite_projeto")
grid <- sp::spsample(pistola, 1000, type= "regular")
colnames(grid@coords) <- colnames(pontos@coords)
gridded(grid) <- TRUE # convert to SpatialPixels
str(grid)
plot(grid)
```

```{r, fig.width=10, warning=FALSE,  fig.cap= "Mapas de predição - saída extendida do georob"}
#ESPACIAL
pred_ponto <- predict(
  vario_fit_error, newdata = grid, type = "response", signif = 0.95,
  control = georob::control.predict.georob(extended.output = TRUE))
sp::gridded(pred_ponto) <- TRUE
spplot(pred_ponto)
```

```{r, fig.width=10}
at <- pred_ponto@data[, c("pred", "lower", "upper")] %>% range(na.rm = TRUE)
at <- seq(at[1], at[2], length.out = 20)
```

```{r, fig.asp=1}
spplot(pred_ponto, zcol = "lower", at = at, main="Limite inferior")
spplot(pred_ponto, zcol="pred", at=at, main="Realização mais provável")
spplot(pred_ponto, zcol="upper", at=at, main="Limite superior")
```

```{r}
#AVALIAÇÃO DA QUALIDADE
nset <- length(pontos) - 1
validacao <- georob::cv(vario_fit_error, nset = nset)
summary(validacao)
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
```

```{r}
plot(validacao)
```

#form5

```{r fig.asp=1, fig.width=7, fig.height=7, fig.cap=" Variograma amostral"}
distmax <-dist(pontos@coords) %>% max() / 3
limites <- seq(0, distmax, length.out = 20)
vario <- georob::sample.variogram(form5,
    data= pontos, locations = ~ X + Y, lag.dist.def = limites, estimator = "matheron") %>%
plot(ylab = 'Seminvariância', xlab = 'Distância de separação (m)', annotate.npairs = TRUE, main = "Semivariograma")
```

```{r}
vario_fit <- 
  georob::fit.variogram.model(
  vario, variogram.model = 'RMexp', param = c(variance = 10, nugget = 0.5, scale = 70), weighting.method = "cressie", method = "BFGS")
summary(vario_fit)
```

```{r, fig.asp = 1, fig.cap=" Variograma amostral (em preto) e função exponencial a ele ajustado (vermelho)"}
plot(vario, xlab = 'Distância de separação (m)', ylab = 'Semivariância', annotate.npairs = TRUE)
lines(vario_fit, col = "red", lty = 'dashed')
```

```{r, warning=FALSE}
nugget <- 0.25
vario_fit_error <- georob::georob(
   form5, pontos, locations = ~ X + Y, variogram.model = 'RMexp', 
 param = c(variance = vario_fit$variogram.object[[1]]$param[['variance']], 
           nugget = nugget,
           snugget = vario_fit$variogram.object[[1]]$param[['nugget']] - nugget,
           scale = vario_fit$variogram.object[[1]]$param[['scale']]),
 fit.param = georob::default.fit.param(nugget = FALSE, snugget = TRUE),
 tuning.psi = 1000, control = georob::control.georob(initial.fixef = 'lm'))

summary(vario_fit_error)
```

```{r}
plot(vario)
lines(vario_fit, col = "blue")
lines(vario_fit_error, col = "red")
```

```{r}
pistola <- raster::shapefile("../data/Contorno/limite_projeto")
grid <- sp::spsample(pistola, 1000, type= "regular")
colnames(grid@coords) <- colnames(pontos@coords)
gridded(grid) <- TRUE # convert to SpatialPixels
str(grid)
plot(grid)
```

```{r}
#AVALIAÇÃO DA QUALIDADE
nset <- length(pontos) - 1
georob::cv(vario_fit_error, nset = nset) %>% summary()
```

```{r}
1 - sum((validacao$pred$data - validacao$pred$pred)^2) / sum((validacao$pred$data - mean(validacao$pred$data))^2)
```

```{r}
plot(validacao)
```


